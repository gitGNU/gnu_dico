#!/bin/sh 
# Apart from these three lines, it is actually a -*- tcl -*- script \
exec wish "$0" -- "$@"
# This file is part of GNU Dico
# Copyright (C) 2012 Sergey Poznyakoff
#
# GNU Dico is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# GNU Dico is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNU Dico.  If not, see <http://www.gnu.org/licenses/>.
#

package require Tk
encoding system "utf-8"

set traceoption 0
set dicod_server ""
set dbname "gcide"

proc fontflags {f {isbold 0}} {
    global fontattr

    return [list -family $fontattr($f,family) -size $fontattr($f,size) \
		-weight [expr {$isbold? "bold": $fontattr($f,weight)}] \
		-slant $fontattr($f,slant)]
}

proc parsefont {f n} {
    global fontattr $f
    
    set fontattr($f,family) [lindex $n 0]
    set s [lindex $n 1]
    if {$s eq {} || $s == 0} {
	set s 10
    } elseif {$s < 0} {
	set s [expr {int(-$s / [winfo fpixels . 1p] + 0.5)}]
    }
    set fontattr($f,size) $s
    set fontattr($f,weight) normal
    set fontattr($f,slant) roman
    foreach style [lrange $n 2 end] {
	switch -- $style {
	    "normal" -
	    "bold"   {set fontattr($f,weight) $style}
	    "roman" -
	    "italic" {set fontattr($f,slant) $style}
	}
    }
}

############################################################################
# Set options
############################################################################
if {[tk windowingsystem] eq "aqua"} {
    set textfont {Monaco 9}
    set uifont {{Lucida Grande} 9}
    set hdrfont {{Lucida Grande} 14 bold}
} else {
    set textfont {Helvetica 14}
    set uifont {Helvetica 11}
    set hdrfont {Helvetica 14 bold}
}

set colors {green red blue magenta darkgrey brown orange}
set errorcolor { black yellow }

parsefont textfont $textfont
eval font create textfont [fontflags textfont]

parsefont uifont $uifont
eval font create uifont [fontflags uifont]

option add *tearOff 0

option add *Text.font textfont startupFile
option add *Listbox.font textfont startupFile

option add *Menu.font uifont startupFile
option add *Button.font uifont startupFile
option add *Checkbutton.font uifont startupFile
option add *Radiobutton.font uifont startupFile
option add *Menubutton.font uifont startupFile
option add *Label.font uifont startupFile
option add *Message.font uifont startupFile
option add *Entry.font textfont startupFile
option add *Combobox.font textfont startupFile
option add *Labelframe.font uifont startupFile
option add *Spinbox.font uifont startupFile

############################################################################
# Define events 
############################################################################
event add <<Paste>> <Shift-Insert>
event add <<Paste>> <Button-2>
event add <<Paste>> <Control-V> 
event add <<Copy>> <Control-C>
event add <<Cut>> <Control-X>

############################################################################
# Color compound manipulation
############################################################################

proc getfg {col} {
    lindex $col 0
}
proc getbg {col} {
    lindex $col 1
}

proc setfg {colname val} {
    global $colname
    lset [set $colname] 0 $val
}
proc setbg {colname val} {
    global $colname
    lset [set $colname] 1 $val
}
    
# Set error header tag
proc seterrheader {args} {
    global errorcolor
    global hdrfont
    
    .c.article tag configure errheader \
	-foreground [getfg $errorcolor] -background [getbg $errorcolor] \
	-font $hdrfont
}

############################################################################
# Setup main window structure
############################################################################

wm title . "GCIDER"
wm protocol . WM_DELETE_WINDOW {savepick; destroy .}

menu .menubar
. configure -menu .menubar
set m .menubar
menu $m.file
$m add cascade -menu $m.file -label File
$m.file add command -label "Save article" -command save_article -underline 0
$m.file add separator
$m.file add command -label "Exit" -command { finish 0 } -underline 1	

$m add cascade -label "Edit" -menu [menu $m.edit] -underline 0
$m.edit add command -label "Appearance" -underline 0 -command appearance_box
$m.edit add command -label "Configure" -command gcider_reconf -underline 0

$m add cascade -label Help -menu [menu $m.help]
$m.help add command -label "About" -command about -underline 1

grid [ttk::frame .c -padding "3 3 12 12"] -column 0 -row 0 -sticky nwes
grid columnconfigure . 0 -weight 1
grid rowconfigure . 0 -weight 1
grid columnconfigure .c 0 -weight 3
grid columnconfigure .c 1 -weight 3

grid columnconfigure .c 3 -weight 3
grid columnconfigure .c 4 -weight 3

grid [ttk::combobox .c.input -textvariable input -width 40 \
	  -exportselection true -font uifont] \
     -column 0 -row 0 -sticky ew

grid [button .c.define -text "Define" -command define] \
     -column 1 -row 0 -columnspan 2 -sticky e
grid [button .c.match -text "Match" -command match] \
     -column 3 -row 0 -sticky e

grid [ttk::combobox .c.strategy -textvariable strategy -state readonly \
	 -font uifont] \
     -column 4 -row 0 -columnspan 2 -sticky ew

grid [text .c.article -state disabled -wrap word \
	   -yscrollcommand ".c.artscroll set"] \
     -column 0 -row 1 -columnspan 2 -sticky nwes

.c.article tag configure seealso -underline 1
.c.article tag bind seealso <Button-1> {
    set res [%W tag prevrange seealso @%x,%y]
    if {[llength $res] != 0} {
	defineword [%W get [lindex $res 0] [lindex $res 1]]
    }
}
.c.article tag bind seealso <Button-3> {
    set res [%W tag prevrange seealso @%x,%y]
    if {[llength $res] != 0} {
	catch {%W tag remove sel sel.first sel.last}
	%W tag add sel [lindex $res 0] [lindex $res 1]
	tk_popup .c.article.popupMenu %X %Y
    }
}
.c.article tag bind seealso <Enter> [list %W config -cursor hand2]
.c.article tag bind seealso <Leave> [list %W config -cursor xterm]

grid [scrollbar .c.artscroll -command ".c.article yview" \
      -orient vertical] -column 2 -row 1 -sticky ns

grid [listbox .c.matches -state disable -yscrollcommand ".c.matchscroll set"] \
      -column 3 -columnspan 2 -row 1 -sticky nwes
grid [scrollbar .c.matchscroll -command ".c.matches yview" \
      -orient vertical] -column 5 -row 1 -sticky nse

############################################################################
# Create input widget popup
############################################################################
set m [menu .c.input.popupMenu]
$m add command -label "Copy" -command {
    entry::Copy .c.input
}
$m add command -label "Cut" -command {
    entry::Cut .c.input
}
$m add command -label "Clear" -command {
    entry::Clear .c.input
}
$m add command -label "Paste" -command {
    if {![info exists tk::Priv(mouseMoved)] || !$tk::Priv(mouseMoved)} {
	entry::Paste .c.input
#        tk::TextPasteSelection %W %x %y
    }
}

# Arrange for it to pop up when the right button is clicked
bind .c.input <Button-3> {
    if {[catch {string range [%W get] [%W index sel.first] \
		    [expr {[%W index sel.last] - 1}]} word] == 0 &&\
	    $word != ""} {
	set state normal
    } else {
	set state disabled
    }
    %W.popupMenu entryconfigure Copy -state $state 
    %W.popupMenu entryconfigure Cut -state $state
    %W.popupMenu entryconfigure Clear -state $state 
    if {[catch {::tk::GetSelection %W CLIPBOARD} sel] == 0 && $sel != ""} {
	%W.popupMenu entryconfigure Paste -state normal
    } elseif { $state == normal } {
	%W.popupMenu entryconfigure Paste -state disabled
    } else {
	return
    }

    tk_popup %W.popupMenu %X %Y
}

############################################################################
# Create article popup menu
############################################################################
set m [menu .c.article.popupMenu]
$m add command -label "Define" -command {
    with_selected_word .c.article defineword
}
$m add command -label "Match" -command {
    with_selected_word .c.article matchword
}
$m add command -label "Copy" -command {
    tk_textCopy .c.article
}

# Arrange for it to pop up when the right button is clicked
bind .c.article <Button-3> {
    if {[catch {%W get sel.first sel.last} word] == 0 && $word != ""} {
	tk_popup .c.article.popupMenu %X %Y
    }
}

############################################################################
# Set the focus and bind events
############################################################################
focus .c.input
bind . <Return> {define}
bind .c.input <<ComboboxSelected>> { define }
bind .c.matches <Double-ButtonPress-1> {
    set sel [.c.matches curselection]
    if {$sel == ""} {
	return
    }
    set word [.c.matches get [lindex $sel 0]]
    .c.input set $word
    defineword $word
}

bind .c.article <Double-2> {
    with_selected_word %W defineword
}

############################################################################
# Auxiliary functions
############################################################################

# Get selection from the widget W and interpret COM if it is not empty
proc with_selected_word {w com} {
    if {[catch {string map {"\n" ""} [$w get sel.first sel.last]} word] == 0} {
	$com $word
    }
}

# About box
proc about {} {
    if [winfo exist .aboutbox] {
	raise .aboutbox
	return
    }
    toplevel .aboutbox
    grab .aboutbox
    wm transient .aboutbox .
    wm protocol .aboutbox WM_DELETE_WINDOW {
	grab release .aboutbox;
	destroy .aboutbox}
    wm resizable .aboutbox 0 0
    grid [ttk::frame .aboutbox.c -padding "3 3 12 12"] \
	  -column 0 -row 0 -sticky nwes
    grid [label .aboutbox.c.name \
          -justify center \
          -font "-adobe-helvetica-medium-r-*-*-*-180-*-*-*-*-*-*" \
	      -text "GCIDER Version 0.1"] \
	 -column 0 -row 0
    grid [label .aboutbox.c.warranty \
          -justify left \
          -font "-adobe-helvetica-medium-r-*-*-*-100-*-*-*-*-*-*" \
	      -text "GCIDER is a viewer for GNU Collaborative dictionary of English.\n\n\
Copyright (C) 2012, Sergey Poznyakoff\n\
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n\
This is free software: you are free to change and redistribute it.\n\
There is NO WARRANTY, to the extent permitted by law."] \
	 -column 0 -row 1
    
    grid [button .aboutbox.c.ok \
          -text "Dismiss" \
          -command {destroy .aboutbox}] -column 0 -row 2
}

# Pop up fatal error window
proc terror {args} {
    errorbox [lindex $args 0] [lindex $args 1]
    exit 1
}

proc errorbox {args} {
    tk_messageBox -title "GCIDER error" -icon error -type ok \
	          -message [lindex $args 0] \
	          -detail [lindex $args 1]
}

proc save_article {} {
    set file [tk_getSaveFile -title "Save article to file" -initialdir ~]
    if {$file == ""} { return }
    set fd [open $file w]
    puts $fd [.c.article get 1.0 end]
    close $fd
}

proc gcider_reconf {} {
    global dicod_server
    global gcide_dbdir
    global result
    
    gcide_configure {\
Please supply new configuration values below.  Press "Cancel" to cancel or
"OK" to submit.	
} \
	-ok { dict_connect errorbox } \
	-canceltext "Cancel" \
	-cancel [subst {
	    set dicod_server $dicod_server
	    set gcide_dbdir $gcide_dbdir
	}]
}

proc gcider_reconfig_or_die {} {
    global dicod_server
    global gcide_dbdir
    global result
    
    gcide_configure {\
Please supply new configuration values below.  Press "Exit" to quit or
"OK" to submit.	
} \
	-ok { dict_connect errorbox }
}

proc gcider_error_reconf {args} {
    errorbox [lindex $args 0] [lindex $args 1]
    gcider_reconfig_or_die
}

############################################################################
# Font selection
proc selfontfam {} {
    global fonttop fontparam

    set i [$fonttop.c.f.fam curselection]
    if {$i ne {}} {
	set fontparam(family) [$fonttop.c.f.fam get $i]
    }
}

proc fontok {w cmd} {
    global fontparam fontpref appcache colparam

    set f $fontparam(font)
    set fontpref($f) [list $fontparam(family) $fontparam(size)]
    if {$fontparam(weight) eq "bold"} {
	lappend fontpref($f) "bold"
    }
    if {$fontparam(slant) eq "italic"} {
	lappend fontpref($f) "italic"
    }
    $w.lb conf -text $fontparam(family) -font $fontpref($f)

    if {[info exists colparam(name)]} {
	$w.lb conf -foreground [getfg $colparam(color)] \
	    -background [getbg $colparam(color)]
	set appcache($f,color) $colparam(color)
    }
    
    fontcan

    set appcache($f,font) $fontpref($f)

    
    if {$cmd != {}} $cmd
}

proc fontcan {} {
    global fonttop fontparam

    if {[info exists fonttop]} {
	catch {destroy $fonttop}
	catch {font delete sample}
	unset fonttop
	unset fontparam
    }
}

proc centertext {w} {
    $w coords text [expr {[winfo width $w] / 2}] [expr {[winfo height $w] / 2}]
}

proc chg_fontparam {v sub op} {
    global fontparam

    font config sample -$sub $fontparam($sub)
}

proc choosefont {cvar w which cmd} {
    global fontparam fontlist fonttop fontattr
    global appcache colparam

    if {[info exists appcache($cvar,color)]} {
	set color $appcache($cvar,color)
	set colparam(name) $appcache($cvar,colorname)
	set colparam(color) $appcache($cvar,color)
    } else {
	set color { black white }
    }

    set fontname $appcache($cvar,fontname)
    set font $appcache($cvar,font)
    parsefont $fontname $font
    
    set fontparam(which) $which
    set fontparam(font) $fontname
    set fontparam(family) [font actual $font -family]
    set fontparam(size) $fontattr($fontname,size)
    set fontparam(weight) $fontattr($fontname,weight)
    set fontparam(slant) $fontattr($fontname,slant)

    set top .fontbox
    set fonttop $top
    
    if [winfo exist $top] {
	raise $top
	$top.samp itemconf text -text $which
	return
    } else {
	toplevel $top
	wm resizable $top 0 0
	grab $top
	wm transient $top .
	wm protocol $top WM_DELETE_WINDOW {
	    grab release $top;
	    destroy $top
	}

	font create sample
	eval font config sample [font actual $font]
	
	grid [ttk::frame $top.c -padding "3 3 12 12"] \
	    -column 0 -row 0 -sticky nwes
	
	grid [label $top.c.l -textvariable fontparam(which)] \
	    -row 0 -column 0 -sticky we
	
	set fontlist [lsort [font families]]
	grid [ttk::frame $top.c.f] -row 1 -column 0 -sticky we
	grid [listbox $top.c.f.fam -listvariable fontlist \
		  -font uifont \
		  -yscrollcommand [list $top.c.f.sb set]] \
	    -row 0 -column 0 -sticky w
	bind $top.c.f.fam <<ListboxSelect>> selfontfam
	grid [scrollbar $top.c.f.sb -command [list $top.c.f.fam yview]] \
	    -row 0 -column 1 -sticky ns
#
	grid [ttk::frame $top.c.sf] -row 2 -column 0 -sticky we
	grid columnconfigure $top.c.sf 0 -weight 3
	grid columnconfigure $top.c.sf 1 -weight 0
	grid columnconfigure $top.c.sf 2 -weight 3
	
	grid [spinbox $top.c.sf.size -from 4 -to 40 -width 4 \
		  -textvariable fontparam(size) \
		  -validatecommand {string is integer -strict %s}] \
	    -row 0 -column 0 -sticky e
	grid [checkbutton $top.c.sf.bold -padx 5 \
		  -font {{Times New Roman} 12 bold} -text "B" -indicatoron 0 \
		  -variable fontparam(weight) -onvalue bold -offvalue normal] \
	    -row 0 -column 1 
	grid [checkbutton $top.c.sf.ital -padx 5 \
		  -font {{Times New Roman} 12 italic} -text "I" \
		  -indicatoron 0  \
		  -variable fontparam(slant) -onvalue italic -offvalue roman] \
	    -row 0 -column 2 -sticky w

	canvas $top.samp -width 150 -height 50 -border 2 -relief sunk \
	    -background [getbg $color]
	set textid [$top.samp create text 100 25 -anchor center \
			-text $which -font sample \
			-fill [getfg $color] -tags text]
	
	grid $top.samp -row 3 -column 0 -sticky we
	bind $top.samp <Configure> [list centertext $top.samp]

	if {[info exists appcache($cvar,color)]} {
	    grid [ttk::frame $top.colbtn] -row 4
	    grid [button $top.colbtn.fg \
		      -text "Fg" \
		      -command [subst {
			  choosecolor $top.samp $textid \
			      "Choose foreground for $which" \
			      $cvar -fill {}
	      }] ]  -row 0 -column 1 -sticky w
	    grid [button $top.colbtn.bg \
		      -text "Bg" \
		      -command [subst {
			  choosecolor $top.samp {} \
			      "Choose background for $which" \
			      $cvar -background {}}]] \
		-row 0 -column 2 -sticky w
	}
	
	grid [ttk::frame $top.buts] -row 5
	grid [button $top.buts.ok -text "OK" \
		  -command [list fontok $w $cmd] \
		  -default active] \
	    -row 0 -column 0
	grid [button $top.buts.can -text "Cancel" -command fontcan \
		  -default normal] \
	    -row 0 -column 1
	bind $top <Key-Return> fontok
	bind $top <Key-Escape> fontcan
	grid $top.buts.ok $top.buts.can
	grid columnconfigure $top.buts 0 -weight 1 -uniform a
	grid columnconfigure $top.buts 1 -weight 1 -uniform a

	trace add variable fontparam write chg_fontparam
    }
    set i [lsearch -exact $fontlist $fontparam(family)]
    if {$i >= 0} {
	$top.c.f.fam selection set $i
	$top.c.f.fam see $i
    }
}

parsefont hdrfont $hdrfont 

proc editfont {base row descr cvar cmd} {
    global appcache

    set w [ttk::frame "$base.editfont$appcache($cvar,fontname)" -padding "3 3 12 12"]
    grid $w -column 0 -row $row -sticky we
    grid columnconfigure $w 0 -weight 3
    grid columnconfigure $w 1 -weight 3

    grid [button $w.btn \
	      -text $descr \
	      -command [list choosefont $cvar $w "$descr" seterrheader]] \
	-row 0 -column 0 -sticky w
    if {[info exists appcache($cvar,color)]} {
	set color $appcache($cvar,color)
    } else {
	set color { black white }
    }
    grid [label $w.lb \
	      -justify center \
	      -relief sunk \
	      -text [font actual $appcache($cvar,font) -family] \
	      -font $appcache($cvar,font) \
	      -foreground [getfg $color] \
	      -background [getbg $color] \
	      -padx 40 \
	     ] -row 0 -column 1 -sticky w
}


############################################################################
# Color selection

proc choosecolor {w id title cvar opt cmd} {
    global colparam

    set color $colparam(color)
    
    if {$opt == "-background"} {
	set n 1
    } else {
	set n 0
    }
    
    set c [tk_chooseColor -initialcolor [lindex $color $n] \
	       -title $title]
    if {$c eq {}} return
    if {$id == {}} {
	$w conf $opt $c
    } else {
	$w itemconfigure $id $opt $c
    }
    lset colparam(color) $n $c
    if {$cmd !={}} $cmd
}

proc appok {} {
    global appcache 

    foreach name [lsort [array names appcache -regexp ".*,\[a-z_\]+name$"]] {
	set kv [split $name ","]
	set key [lindex $kv 0]
	set val [lindex $kv 1]

	set subkey [string replace $val end-3 end ""]
	set varname $appcache($key,$val)
	global $varname
	set $varname $appcache($key,$subkey)

	if [info exists appcache($key,flush)] {
	    $appcache($key,flush) $varname
	}
    }

    appcan
}

proc appcan {} {
    grab release .appbox;
    destroy .appbox
}

proc flushfont {fontname} {
    global fontattr

    global $fontname
    set font [set $fontname]
    parsefont $fontname $font
    eval font configure $fontname [fontflags $fontname]
    
}

# Create appearance configuration box
proc appearance_box {} {
    global errorcolor hdrfont textfont uifont
    global appcache

    set appcache(uifont,fontname) uifont
    set appcache(uifont,font) $uifont
    set appcache(uifont,flush) flushfont

    set appcache(textfont,fontname) textfont
    set appcache(textfont,font) $textfont
    set appcache(textfont,flush) flushfont
    
    set appcache(hdrfont,fontname) hdrfont
    set appcache(hdrfont,font) $hdrfont
    set appcache(hdrfont,colorname) errorcolor
    set appcache(hdrfont,color) $errorcolor
    set appcache(hdrfont,flush)  seterrheader
    

    if [winfo exist .appbox] {
	raise .appbox
	return
    }
    toplevel .appbox
    wm resizable .appbox 0 0
    grab .appbox
    wm transient .appbox .
    wm protocol .appbox WM_DELETE_WINDOW {
	grab release .appbox;
	destroy .appbox}

    grid [ttk::frame .appbox.c -padding "3 3 12 12"] \
	  -column 0 -row 0 -sticky nwes
    
    editfont .appbox.c 2 "GUI font" uifont {}
    editfont .appbox.c 3 "Text font" textfont {}
    editfont .appbox.c 4 "Header font" hdrfont {}
    
    grid [ttk::frame .appbox.c.buttons -padding "3 3 12 12"] \
	-column 0 -row 5 -columnspan 2 -sticky we
    grid columnconfigure .appbox.c.buttons 0 -weight 3
    grid columnconfigure .appbox.c.buttons 1 -weight 3    
    
    grid [button .appbox.c.buttons.ok \
	      -text "OK" \
	      -command appok ]\
	-row 0 -column 0 -sticky e -padx 5

    grid [button .appbox.c.buttons.cancel \
	      -text "Cancel" \
	      -command appcan ]\
	-row 0 -column 1 -sticky w -padx 5

    tkwait window .appbox
}

############################################################################
# Configuration routines
############################################################################

# Directory where our configuration files are kept
set cfgdir ~/.gcider
# Directory where GCIDE files reside
set gcide_dbdir ""

# Dicod configuration template
set dicod_config {/* Dicod configuration file created by GCIDER on [clock format [clock seconds] -gmt true] */
capability (mime);
mode inetd;
pidfile "$cfgdir/dicod.pid";
load-module (substr,word);
load-module gcide;
database {
	name "gcide";
        handler "gcide dbdir=$gcide_dbdir";
}
server-info "Local GCIDE server"; 
/* End of dicod.conf */
}

# Check the validity of $dicod_server and $gcide_dbdir.  If the check fails,
# return 1.  Otherwise, create the gcider configuration and return 0
proc submit_config {} {
    global gcide_dbdir
    global cfgdir
    global dicod_server
    global dicod_config
    
    if {$dicod_server == ""} {
	tk_messageBox -title "GCIDER error" -icon error -type ok \
	              -message "Please select server program to use"
	return 1
    }
	
    if {![file executable $dicod_server]} {
	tk_messageBox -title "GCIDER error" -icon error -type ok \
	          -message "The server program you selected is not executable"
	return 1
    }

    if {$gcide_dbdir == ""} {
	tk_messageBox -title "GCIDER error" -icon error -type ok \
	              -message "Please define the location of GCIDE"
	return 1
    }

    if {![file isdirectory $gcide_dbdir]} {
	tk_messageBox -title "GCIDER error" -icon error -type ok \
	              -message "GCIDE location is not a directory"
	return 1
    }

    foreach let {A B C D E F G H I J K L M N O P Q R S T U V W X Y Z} {
	if {![file exists "$gcide_dbdir/CIDE.$let"]} {
	    tk_messageBox -title "GCIDER error" -icon error -type ok \
		    -message "$gcide_dbdir does not look like a valid GCIDE directory" \
		    -detail "$gcide_dbdir/CIDE.$let does not exist"
	    return 1;
	}
    }

    if {![file isdirectory $cfgdir]} {
	file mkdir $cfgdir
    }
    saveconf
    
    set fd [open $cfgdir/dicod.conf "w"]
    puts $fd [subst $dicod_config]
    close $fd
    
    return 0
}

# Pop-up a configuration box.  When submitted, call submit_config to
# create the configuration.  If it fails, retry.
proc gcide_configure {args} {
    global dicod_server
    global env

    set okcom { set x 0 }
    set exitcom "exit 1"
    set exittext "Exit"

    set text [lindex $args 0]
    for {set i 1} {$i < [llength $args]} {incr i} {
	if {[lindex $args $i] == "-ok"} {
	    incr i
	    set okcom [lindex $args $i]
	} elseif {[lindex $args $i] == "-cancel"} {
	    incr i
	    set exitcom [lindex $args $i]
	} elseif {[lindex $args $i] == "-canceltext"} {
	    incr i
	    set exittext [lindex $args $i]
	}
    }
    
    if {$dicod_server == ""} {
	foreach dir [split $env(PATH) ":"] {
	    if {[file executable $dir/dicod]} {
		set dicod_server $dir/dicod
		break
	    }
	}
	if {$dicod_server == ""} {
	    set dicod_server "dicod"
	}
    }
    
    if [winfo exists .initcfg] {
	raise .initcfg
	return
    }
    toplevel .initcfg
    wm title .initcfg "GCIDER Viewer Configuration"
    wm resizable .initcfg 0 0
    grab .initcfg
    wm transient .initcfg .
    wm protocol .initcfg WM_DELETE_WINDOW {grab release .initcfg; destroy .initcfg}
    
    grid [ttk::frame .initcfg.c -padding "3 3 12 12"] \
	  -column 0 -row 0 -sticky nwes
    grid [label .initcfg.c.descr \
          -justify left \
	  -text $text] \
	  -column 0 -columnspan 3 -row 0 -sticky new -padx 5
    grid [label .initcfg.c.srvlabel \
          -justify left \
          -text "Path to dicod server"] \
	  -column 0 -row 1 -sticky w -padx 5
    grid [entry .initcfg.c.srventry \
          -textvariable dicod_server] \
	  -column 1 -row 1 -sticky e -padx 5
    grid [button .initcfg.c.srvb -text "Browse" \
	  -command {
	      global dicod_server
	      set dicod_server [tk_getOpenFile -title "Dicod server" -initialdir ~]
              raise .initcfg}] \
	-column 2 -row 1 -sticky e
    
    grid [label .initcfg.c.cidelabel \
          -justify left \
          -text "Path to GCIDE dictionary"] \
	  -column 0 -row 2 -sticky w -padx 5
    grid [entry .initcfg.c.cideentry \
          -textvariable gcide_dbdir] \
	  -column 1 -row 2 -sticky e -padx 5
    grid [button .initcfg.c.cideb -text "Browse" \
	  -command {
	      global gcide_dbdir
	      set gcide_dbdir [tk_chooseDirectory -initialdir ~]
	      raise .initcfg}] \
	-column 2 -row 2 -sticky e
    
    grid [ttk::frame .initcfg.c.buttons -padding "3 3 12 12"] \
	  -column 0 -row 3 -columnspan 3 -sticky we
    grid columnconfigure .initcfg.c.buttons 0 -weight 1
    grid columnconfigure .initcfg.c.buttons 1 -weight 1
    set res 1
    grid [button .initcfg.c.buttons.ok \
          -text "OK" \
	      -command [subst {
		  if {\[eval $okcom\] || \[submit_config\]} {
		      raise .initcfg
		  } else {
		      grab release .initcfg
		      destroy .initcfg
		  }
		  } ] ] -column 0 -row 0  -sticky e -padx 10
    grid [button .initcfg.c.buttons.exit \
	      -text $exittext \
	      -command [subst { grab release .initcfg; destroy .initcfg; $exitcom }] ] -column 1 -row 0 -sticky w -padx 20
    tkwait window .initcfg
}

# Save program setup to a "pick file"
proc savepick {} {
    global input
    global cfgdir
    global input
    global stratname
    
    set fd [open $cfgdir/pick "w"]
    if [info exists input] {
	puts $fd "\[input\]"
	puts $fd $input
	foreach word [.c.input cget -values] {
	    puts $fd $word
	}
    }
    puts $fd "\[strategy\]"
    puts $fd [lindex $stratname [.c.strategy current]]
    puts $fd "\[matches\]"
    puts $fd [.c.matches curselection]
    foreach word [.c.matches get 0 end] {
	puts $fd $word
    }
    
    close $fd
}

##############################################
# Additional routines used by loadpick below
##############################################
proc load_variable_input {args} {
    .c.input set [lindex $args 0]
    .c.input configure -values [lrange $args 1 end]    
}

proc load_variable_strategy {args} {
    global strategy
    
    set strategy [lindex $args 0]
}

proc load_variable_matches {args} {
    set num [lindex $args 0]
    set values [lrange $args 1 end]
    if {[llength $values]>0} {
	.c.matches configure -state normal
	foreach word $values {
	    .c.matches insert end $word
	}
	.c.matches selection set $num
	.c.matches yview $num
    }
}

proc load_variable {args} {
    set keyword [lindex $args 0]
    set value [lindex $args 1]
    set pn [join [list "load_variable_" $keyword] ""]
    catch {
	eval $pn $value
    }    
}

# Load program setup from the pick file
proc loadpick {} {
    global input
    global strategy
    global cfgdir
    global input

    if {[catch {open $cfgdir/pick r} fd]} {
	return
    }
    for {set res [gets $fd line]} {$res >= 0} {set res [gets $fd line]} {
	if [regexp "^#.*" $line] {
	    continue
	} elseif [regexp "\\\[(.*)\\\]" $line dummy kw] {
	    if [info exists keyword] {
		load_variable $keyword $value
	    }
	    set keyword $kw
	    set value {}
	} else {
	    lappend value $line
	}
    }
    if [info exists keyword] {
	load_variable $keyword $value
    }
    close $fd
}

proc saveconf {} {
    global cfgdir
    
    set fd [open $cfgdir/config "w"]

    foreach var { dicod_server gcide_dbdir textfont uifont \
		      hdrfont errorcolor } {
	global $var
	set value [set $var]
	puts $fd [list set $var $value]
    }
    close $fd
}

# Save configuration and exit the program
proc finish {code} {
    saveconf
    savepick
    exit $code
}

############################################################################
# Read the configuration or create it, if it does not exist.
############################################################################
if [file exists $cfgdir/config] {
    catch {source $cfgdir/config}
    foreach font {textfont uifont} {flushfont $font}
    seterrheader
    loadpick
} else {
    gcide_configure {\
Welcome to GCIDER, a viewer for GNU Collaborative Dictionary of English (GCIDE).
This seems to be its first start up.  To operate, it needs to know two parameters,
which this dialog box asks you to provide.  You will need to do this only once,
GCIDER will save these data and reuse them on its next startup.
}  "Exit" { exit 1 }
}

# Update fonts

############################################################################
# DICT protocol routines
############################################################################
# If $traceoption is set, print tracing information on stderr.  First argument
# is the "state word", and will be followed by a colon and a space on output.
# The rest of arguments are output verbatim.
proc dict_trace {args} {
    global traceoption
    if {$traceoption} {
	puts -nonewline stderr [lindex $args 0]
	puts -nonewline stderr ": "
	eval puts stderr [lrange $args 1 end]
    }
}

# Read and return one line of response from the server
proc dictread {} {
    global pipe
    
    set reply [gets $pipe]
    dict_trace RECV "$reply"
    return $reply
}

# Get the server response and split it into initial 3-digit code and
# textual string.
proc getrepl {} {
    set reply [dictread]
    if [regexp {([1-5][0-9][0-9])\s+(.*)} $reply dummy code text] {
	return [list $code $text]
    } else {
	return [list 0]
    }
}

# Send command to the server.  Arguments are output one by one,
# with a single space inserted between each pair of them.  The first argument
# (the command verb) is output verbatim, the rest of them are quoted.
# Output ends with a CRLF.
proc dictwrite {args} {
    global pipe

    dict_trace SEND "$args"
    puts -nonewline $pipe [lindex $args 0]
    foreach word [lrange $args 1 end] {
	set esc [string map {"\"" "\\\""} $word]
	puts -nonewline $pipe " \"$esc\""
    }
    puts -nonewline $pipe "\r\n"
}

# Read definitions and insert them into the article widget.
proc readdefns {} {
    set num 1

    set reply [dictread]
    while {[regexp {151\s+.*} $reply]} {
	.c.article insert end "$num. "
	incr num
	set reply [dictread]
	while {$reply != "."} {
	    set beg 0
	    foreach x [regexp -indices -all -inline {\{[^\{\}]+\}} $reply] {
		set start [lindex $x 0]
		set end [expr [lindex $x 1]]
		if {$beg < $start} {
		    .c.article insert end [string range $reply \
					          $beg [expr $start - 1]]
		}
		.c.article insert end [string range $reply \
					   [expr $start + 1] [expr $end - 1]]
		set len [expr $end - $start ]
		.c.article tag add seealso "end - $len chars" "end - 1 chars"
		set beg [expr $end + 1]

	    }
	    .c.article insert end [string range $reply $beg end]
	    .c.article insert end "\n"
	    set reply [dictread]
	}
	.c.article insert end "\n"
	set reply [dictread]
    }
    # FIXME reply code: 250?
    return 0
}

# Define $word
proc defineword {word} {
    global dbname
    global input
    
    dictwrite "DEFINE" $dbname $word
    set res [getrepl]
    set code [lindex $res 0]
    set text [lindex $res 1]
    .c.article configure -state normal
    .c.article delete 1.0 end
    if {$code == 150} {
	set values [.c.input cget -values]
	if {[lsearch -exact $values $word] == -1} {
	    .c.input configure -values [linsert $values 0 $word]
	}
	if {$word != $input} {
	    .c.input set $word
	}
	
	regexp {([1-5][0-9][0-9])\s+(.*)} $text dummy count rest
	readdefns
    } elseif {$code == 552} {
	# FIXME: font?
	.c.article insert end "No definition for \"$word\""
	.c.article tag add errheader 1.0 end
    } elseif {$code <= 0} {
	tk_messageBox -title "GCIDER error" -icon error -type ok \
	              -message "I/O error communicating with the server"
    } else {
	tk_messageBox -title "GCIDER error" -icon error -type ok \
	              -message "DICT protocol error" \
	              -detail "$code $res"
    }
    .c.article configure -state disabled
}

# The "Define" button command
proc define {} {
    global input

    if {![info exists input] || $input == ""} {
	return
    }
    defineword $input
}

# Produce a list of matches of $headword using the currently selected
# strategy and fill the match widget with them.
proc matchword {headword} {
    global dbname
    global strategy
    global stratname
    
    set strat [lindex $stratname [.c.strategy current]]
    
    .c.matches configure -state normal
    .c.matches delete 0 end
    dictwrite MATCH $dbname $strat $headword
    set res [getrepl]
    set code [lindex $res 0]
    set text [lindex $res 1]
    set matches {}
    if {$code == 152} {
	# Read matches
	for {set reply [dictread]} {$reply != "."} {set reply [dictread]} {
	    regexp {\S+\s+(.*)} $reply dummy word
	    lappend matches [string trim $word "\""]
	}
	getrepl
	lsort -nocase $matches
	foreach word $matches {
	    .c.matches insert end $word
	}
    } elseif {$code == 552} {
	# No matches, skip it
	.c.matches configure -state disabled
    } else {
	tk_messageBox -title "GCIDER error" -icon error -type ok \
	              -message "Unexpected reply from server" \
	              -detail "$res"
	.c.matches configure -state disabled
    }
}

# The "Match" button handler
proc match {} {
    global input
    
    if {[info exists input] && $input != ""} {
	matchword $input
    }
}

proc dict_connect {args} {
    global pipe
    global dicod_server
    global cfgdir
    global stratname
    global stratdescr

    if {[llength $args]} {
	set errproc [lindex $args 0]
    } else {
	set errproc terror
    }
    set cmd [concat "$dicod_server --config " \
		 [file normalize $cfgdir/dicod.conf] \
		 " -i --stderr"]
    if {[catch {open "| $cmd 2>$cfgdir/log" "r+"} pipe]} {
	$errproc "Cannot connect to server" $::errorInfo
	return 1
    }
    fconfigure $pipe -buffering line 

    # Get initial reply
    set res [getrepl]
    set code [lindex $res 0]
    if {$code <= 0} {
	$errproc "Cannot connect to dicod server $dicod_server"
	return 1
    } elseif {$code != 220} {
	set text [lindex $res 1]
	$errproc "Dicod server refuses to talk to me" \
	         "Its reply: $code $text"
	return 1
    }

    # Fill in lists of strategies
    # Two parallel lists are kept: $stratname contains strategy names, for use
    # in MATCH command.  $stratdescr keeps the corresponding textual
    # descriptions for use by humans.
    dictwrite "SHOW STRAT"
    set res [getrepl]
    set code [lindex $res 0]
    if {$code != 111} {
	$errproc "Cannot get list of strategies" $res
	return 0
    }
    regexp {([0-9]+)\s.*} [lindex $res 1] dummy count
    set i 0
    set stratname [list "."]
    set stratdescr [list "Default"]
    for {set reply [dictread]} {$reply != "."} {set reply [dictread]} {
	incr i
	regexp {(\S+)\s+(.*)} $reply dummy name descr
	lappend stratname $name
	lappend stratdescr [string trim $descr "\""]
    }
    getrepl

    # Configure the strategy widget
    .c.strategy configure -values $stratdescr
    set ind 0
    if [info exists strategy] {
	set ind [lsearch $stratname $strategy]
	if {$ind < 0} {
	    set ind 0
	}
    }
    .c.strategy current $ind
    return 0
}
############################################################################
# Launch the server
############################################################################
dict_connect gcider_error_reconf

# Define the last defined word
define

# And enter the main event loop...
# Local variables:
# mode: tcl
# End:
