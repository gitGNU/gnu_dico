# $Id: mkbushufont,v 1.1 2001/11/03 22:34:09 gray Exp $
# This script generates a bushu font.
#-----------------------------------------------------------------------
# usage: mkbushufont glyphs
# where glyphs are the names of xbm files containing character pictures.
# The names should have the form:
#	.*[0-9]+.*\.xbm
# where [0-9]+ represents the number of the character described by the
# given bitmap.

if [ $# -eq 0 ] ; then
	echo "$0: generate a bushu font."
	echo "usage: $0 glyphs"
	exit 0
fi

# Construct bdf header
cat - <<EOF
STARTFONT 2.1
COMMENT 16x16 bushu font
COMMENT named "Bushu 16-dots Matrix Character Patterns for Display Devices"
FONT -gray-fixed-medium-r-normal--16-150-75-75-C-160-bushu.5.1999-0
SIZE 6 78 78
FONTBOUNDINGBOX 16 16 0 2
STARTPROPERTIES 19
FONT_ASCENT 14
FONT_DESCENT 2
DEFAULT_CHAR 255 
COPYRIGHT "from Sergey Poznyakoff, by permission to use"
FONTNAME_REGISTRY ""
FOUNDRY "gjdict"
FAMILY_NAME "Fixed"
WEIGHT_NAME "Medium"
SLANT "R"
SETWIDTH_NAME "Normal"
ADD_STYLE_NAME ""
PIXEL_SIZE 16
POINT_SIZE 150
RESOLUTION_X 75
RESOLUTION_Y 75
SPACING "C"
AVERAGE_WIDTH 160
CHARSET_REGISTRY "gjdict.5.1999"
CHARSET_ENCODING "0"
ENDPROPERTIES
EOF

echo "CHARS `expr $# + 1`"

ENCODING=0
# The `` part of the `for' header below sorts the passed names numerically
# by the character number
for i in `echo $* | awk '
{
    for (i=1; i<=NF; i++) {
	match($i, "[0-9]+\.")	
	s=substr($i, RSTART, RLENGTH-1)
	ary[s] = $i
    }
}

END {
    for (i in ary)
	print i " " ary[i]
}' | sort -n | awk '{ for (i=2; i<=NF; i+=2) print $i}'`
do
	awk '
BEGIN {
    SWIDTH="96 0"
    DWIDTH="16 0"
    BBX="16 16 0 -2"
}

function charheader(num) {
    print "STARTCHAR " num
    print "ENCODING " num
    print "SWIDTH " SWIDTH
    print "DWIDTH " DWIDTH
    print "BBX " BBX
    print "BITMAP"
}

/static unsigned char .*_bits/ {
    match($0, "[0-9]+\.")
    charheader(substr($0, RSTART, RLENGTH-1))
}

/0x[0-9a-fA-F][0-9a-fA-F],/ {
    for (i=1; i<=NF; i++) {
	bits[i] = substr($i, 3, 2)
    }
    for (i=1; i<=NF; i+=2) {
	print bits[i+1] bits[i] | "revbits" # LSB first
    }
}

END {
    print "ENDCHAR"
}
' $i
done

cat - <<EOF
STARTCHAR 255
ENCODING 255
SWIDTH 96 0
DWIDTH 16 0
BBX 16 16 0 -2
BITMAP
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
ENDCHAR
EOF

echo "ENDFONT"
